/* Código do Usuário */

package Analisadores;
import java_cup.runtime.Symbol;
import java.util.LinkedList;


parser code
{:
    public String resultado = "";
    public static LinkedList<TError> TabelaERSintatico = new  LinkedList<TError>();


    public void syntaxError(Symbol symbol){

        String lexema = symbol.value.toString();
        int linha = symbol.right;
        int coluna = symbol.left;
        
        System.out.println("Erro sintático!");
        System.out.println("\tLexema:   " + lexema);
        System.out.println("\tLinha: " + linha);
        System.out.println("\tColuna: " + coluna);



        TError dados = new TError(lexema, linha, coluna, "Erro Sintatico",  "Caractere nao reconhecido!");
        TabelaERSintatico.add(dados);   
    }

    public void unrecoveredSyntaxError(Symbol symbol) throws java.lang.Exception{
        String lexema = symbol.value.toString();
        int linha = symbol.right;
        int coluna = symbol.left;

        System.out.println("Erro sintatico irrecuperavel!");
        System.out.println("\tLexema:   " + lexema);
        System.out.println("\tLinha: " + linha);
        System.out.println("\tColuna: " + coluna);

        TError dados = new TError(lexema, linha, coluna, "Erro Sintatico",  "Caractere nao reconhecido!");
        TabelaERSintatico.add(dados);
    }
    
:}

    //Ações Gramaticais

action code {::}


/* Declaracoes */

    //Terminais
        //Palavras chave
    
terminal abstract, ampersand;
terminal boolean, break, byte;
terminal case, catch, char, clas, CONTINUE;
terminal d, default, do, double;
terminal e, else, extend;
terminal f, false, final, finally, float, for;
terminal if, implements, impor, instanceof, int, interface;
terminal l, long;
terminal native, new, null;
terminal packag, private, protected, public;
terminal return;
terminal short, static, supe, switch, synchronized;
terminal this, threadsafe, throw, transient, true, try;
terminal while;
terminal x;

terminal and, xor, or, lthen, dlthen, lequ, equequ, bthen, bequ, dbthen, tbthen, mod, plus, minus;
terminal openpar, closepar;
terminal equ, xorequ, andequ, plusequ, minusequ, multequ, div, divequ, modequ, sorequ, orequ, neequ;
terminal ne, plusplus, minusminus, binneg;
terminal quest, openbrac, closebrac, openkeys, closekeys, comma, semic, dot, colon;
terminal strg;
terminal comments1, comments2;
terminal importstar;
terminal id, dec_digits, int_literal, text;


    //Nao Terminais

non terminal arglist, bit_expression, casting_expression, character, class_declaration, class_name;
non terminal compilation_unit, constructor_declaration, creating_expression, decimal_digits, doc_comment, do_statement;
non terminal exponent_part, expression, field_declaration, float_literal, float_type_suffix, for_statement;
non terminal identifier, if_statement, import_statement, integer_literal, interface_declaration, interface_name;
non terminal literal_expression, logical_expression, method_declaration, modifier, numeric_expression, package_name;
non terminal package_statement, parameter, parameter_list, statement, statement_block, static_initializer;
non terminal string, string_expression, switch_statement, testing_expression, try_statement, type;
non terminal type_declaration, type_specifier, variable_declaration, variable_declarator, variable_initializer, while_statement;

//Auxiliares

non terminal comma_expression_loop;
non terminal modifier_loop, extends_classname_optional, implements_interface_optional, interface_comma_loop, field_declaration_loop;
non terminal package_statement_op, import_statement_loop, type_declaration_loop;
non terminal parameter_list_optional;
non terminal arglist_optional, expression_optional_brac, colchetes_loop;
non terminal doc_comment_optional;
non terminal decimal_digits_optional, exponent_part_optional, float_type_suffix_optional;
non terminal expression_optional;
non terminal else_statement_optional;
non terminal comma_parameter_loop;
non terminal identifier_optional;
non terminal statement_loop;
non terminal character_loop;
non terminal case_expression_default_statement_loop;
non terminal catch_parameter_statement_loop, finally_statement_optional;
non terminal comma_variable_declarator_loop;
non terminal equ_variable_initializer_optional;
non terminal variables_optional, comma_variable_initializer_loop, comma_optional;
non terminal modifier_optional;
non terminal bit_expression_2;

precedence nonassoc dot, openpar, openbrac;
precedence left plus, minus;

start with compilation_unit;

 
/* Gramática */

//1

//compilation_unit ::=  package_statement import_statement type_declaration;
					
arglist ::= expression comma_expression_loop ;

comma_expression_loop ::= comma expression comma_expression_loop
						| /* vazio*/ ;
						
bit_expression ::= binneg expression
				| expression bit_expression_2;
				
bit_expression_2 ::= bequ expression
				| dlthen expression
				| dbthen expression
				| tbthen expression;
				
casting_expression ::= openpar type closepar expression;

character ::= id;

class_declaration ::= modifier_loop clas identifier extends_classname_optional implements_interface_optional openkeys field_declaration_loop closekeys;

modifier_loop ::= modifier modifier_loop
				| /* vazio */ ; 
				
extends_classname_optional ::= extend class_name
							| /* vazio */ ;

implements_interface_optional ::= implements interface_name interface_comma_loop
								| /* vazio */ ;
								
interface_comma_loop ::= comma interface_name interface_comma_loop
						| /* vazio */ ;
							
field_declaration_loop ::= field_declaration field_declaration_loop 
						| /* vazio */ ;
						
class_name ::= identifier
			| package_name dot identifier;
			
compilation_unit ::= package_statement_op import_statement_loop type_declaration_loop;

package_statement_op ::= package_statement
						| /* vazio */;
						
import_statement_loop ::= import_statement import_statement_loop
						| /* vazio */ ;
						
type_declaration_loop ::= type_declaration type_declaration_loop
						| /* vazio */ ;
						
constructor_declaration ::= modifier_loop identifier openpar parameter_list_optional closepar;

parameter_list_optional ::= parameter_list
						| /* vazio */ ;
						
creating_expression ::= new class_name openpar arglist_optional closepar
					| new type_specifier expression_optional_brac colchetes_loop
					| new openpar expression closepar;
					
arglist_optional ::= arglist
					| /* vazio */ ;
					
expression_optional_brac ::= openbrac expression closebrac
					| /* vazio */;
					
colchetes_loop ::= openbrac closebrac colchetes_loop
					| /* vazio */ ;
					
decimal_digits ::= dec_digits;

doc_comment ::= comments2 text comments1;

do_statement ::= do statement while openpar expression closepar semic;

exponent_part ::= e decimal_digits
				| e plus decimal_digits
				| e minus decimal_digits;
				
expression ::= numeric_expression
             | testing_expression
             | logical_expression
             | string_expression
             | bit_expression
             | casting_expression
             | creating_expression 
             | literal_expression 
             | null
             | supe
             | this 
             | identifier 
             | openpar expression closepar
             | expression openpar arglist_optional closepar
             | expression openbrac expression closebrac
             | expression dot expression
             | expression comma expression
             | expression instanceof class_name
             | expression instanceof interface_name;
             
field_declaration ::= doc_comment_optional method_declaration
					| doc_comment_optional constructor_declaration
					| doc_comment_optional variable_declaration
					| static_initializer
					| semic;
					
					
doc_comment_optional ::= doc_comment
					| /* vazio */;
					
float_literal ::= decimal_digits dot decimal_digits_optional exponent_part_optional float_type_suffix_optional
				| dot decimal_digits exponent_part_optional float_type_suffix_optional
				| decimal_digits exponent_part_optional float_type_suffix_optional;
					
decimal_digits_optional ::= decimal_digits
						| /* vazio */;
						
exponent_part_optional ::= exponent_part
						| /* vazio */;
						
float_type_suffix_optional ::= float_type_suffix
							| /* vazio */;
							
float_type_suffix ::= d
					| f;
					
for_statement ::= openpar variable_declaration expression_optional semic expression_optional semic closepar statement
				| openpar expression semic expression_optional semic expression_optional semic closepar statement
				| openpar semic expression_optional semic expression_optional semic closepar statement;

expression_optional ::= expression
					| /* vazio */;
					
identifier ::= id;

if_statement ::= if openpar expression closepar statement else_statement_optional;

else_statement_optional ::= else statement
							| /* vazio */ ;
							
import_statement ::= impor package_name dot importstar semic semic
					| impor class_name semic
					| impor interface_name semic;
					
integer_literal ::= int_literal;

interface_declaration ::= modifier_loop interface identifier openkeys field_declaration_loop closekeys
						| modifier_loop interface identifier extend interface_name interface_comma_loop openkeys field_declaration_loop closekeys;
						
interface_name ::= identifier
				| package_name dot identifier;
				
literal_expression ::= integer_literal
					| float_literal
					| string
					| character;
					
logical_expression ::= ne expression
					| expression ampersand expression
					| expression ampersand equ expression
					| expression or expression
					| expression sorequ expression
					| expression xor expression
					| expression xorequ expression
					| expression ampersand ampersand expression
					| expression orequ expression
					| expression mod expression
					| expression modequ expression
					| expression quest expression colon expression
					| true
					| false;
					
method_declaration ::= modifier_loop type identifier openpar parameter_list_optional closepar colchetes_loop statement_block
					| modifier_loop type identifier openpar parameter_list_optional closepar colchetes_loop semic;
					
modifier ::= public
           | private
           | protected
           | static
           | final
           | synchronized
           | abstract
           | threadsafe
           | transient;
           
numeric_expression ::= minus expression
					| plusplus expression
					| minusminus expression
					| expression plusplus
					| expression minusminus
					| expression plus expression
					| expression plusequ expression
					| expression minus expression
					| expression minusequ expression
					| expression importstar expression
					| expression multequ expression
					| expression div expression
					| expression divequ expression
					| expression mod expression
					| expression modequ expression;
					
package_name ::= identifier
				| package_name dot identifier;
				
package_statement ::= packag package_name semic;

parameter ::= type identifier colchetes_loop;

parameter_list ::= parameter comma_parameter_loop;

comma_parameter_loop ::= comma parameter comma_parameter_loop
						| /* vazio */ ;
						
statement ::= variable_declarator
            | expression semic
            | statement_block
            | if_statement
            | do_statement
            | while_statement
            | for_statement
            | try_statement
            | switch_statement
            | synchronized openpar expression closepar statement
            | return expression_optional semic 
            | throw expression semic
            | identifier colon statement 
            | break identifier_optional semic
            | CONTINUE identifier_optional semic
            | semic;						
						
identifier_optional ::= identifier
					| /* vazio */ ;
					
statement_block ::= openkeys statement_loop closekeys;	

statement_loop ::= statement statement_loop
				| /* vazio */ ;
				
static_initializer ::= static statement_block;

string ::= strg character_loop strg;

character_loop ::= character character_loop
				| /* vazio */ ;
				
string_expression ::= expression plus expression
					| expression plusequ expression;
					
switch_statement ::= switch openpar expression closepar openkeys case_expression_default_statement_loop closekeys;

case_expression_default_statement_loop ::= case expression colon case_expression_default_statement_loop
										| default colon case_expression_default_statement_loop
										| statement;

testing_expression ::= expression bthen expression
					| expression lthen expression
					| expression lequ expression
					| expression bequ expression
					| expression equequ expression
					| expression neequ expression;
					
try_statement ::= try statement catch_parameter_statement_loop finally_statement_optional;

catch_parameter_statement_loop ::= catch openpar parameter closepar statement catch_parameter_statement_loop
								| /* vazio */;
								
finally_statement_optional ::= finally statement
							| /* vazio */ ;
				
type ::= type_specifier colchetes_loop;

type_declaration ::= doc_comment_optional class_declaration semic
					| doc_comment_optional interface_declaration semic;

type_specifier ::= boolean
                 | byte
                 | char
                 | short
                 | int
                 | float
                 | long 
                 | double
                 | class_name
                 | interface_name;
                 
variable_declaration ::= modifier_optional type variable_declarator comma_variable_declarator_loop semic;

modifier_optional ::= modifier
					| /* vazio */;

comma_variable_declarator_loop ::= comma variable_declarator comma_variable_declarator_loop
								| /* vazio */;
					
variable_declarator ::= identifier colchetes_loop equ_variable_initializer_optional;	

equ_variable_initializer_optional ::= equ variable_initializer	
									| /* vazio */ ;		
									
variable_initializer ::= expression
						| openkeys variables_optional closekeys;
						
variables_optional ::= variable_initializer comma_variable_initializer_loop	comma_optional
					| /* vazio */ ;

comma_variable_initializer_loop ::= comma variable_initializer comma_variable_initializer_loop
								| /* vazio */ ;

comma_optional ::= comma
				| /*vazio*/ ;
				
while_statement ::= while openpar expression closepar statement;
						
