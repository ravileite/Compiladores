/* Código do Usuário */

package Analisadores;
import java_cup.runtime.Symbol;
import java.util.LinkedList;


parser code
{:
    public String resultado = "";
    public static LinkedList<TError> TabelaERSintatico = new  LinkedList<TError>();


    public void syntaxError(Symbol symbol){

        String lexema = symbol.value.toString();
        int linha = symbol.right;
        int coluna = symbol.left;
        
        System.out.println("Erro sintático!");
        System.out.println("\tLexema:   " + lexema);
        System.out.println("\tLinha: " + linha);
        System.out.println("\tColuna: " + coluna);



        TError dados = new TError(lexema, linha, coluna, "Erro Sintatico",  "Caractere nao reconhecido!");
        TabelaERSintatico.add(dados);   
    }

    public void unrecoveredSyntaxError(Symbol symbol) throws java.lang.Exception{
        String lexema = symbol.value.toString();
        int linha = symbol.right;
        int coluna = symbol.left;

        System.out.println("Erro sintatico irrecuperavel!");
        System.out.println("\tLexema:   " + lexema);
        System.out.println("\tLinha: " + linha);
        System.out.println("\tColuna: " + coluna);

        TError dados = new TError(lexema, linha, coluna, "Erro Sintatico",  "Caractere nao reconhecido!");
        TabelaERSintatico.add(dados);
    }
    
:}

    //Ações Gramaticais

action code {::}


/* Declaracoes */

    //Terminais
        //Palavras chave
    
terminal ABSTRACT, AMPERSAND;
terminal BOOLEAN, BREAK, BYTE;
terminal CASE, CATCH, CHAR, CLAS, CONTINUE;
terminal D, DEFAULT, DO, DOUBLE;
terminal E, ELSE, EXTEND;
terminal F, FALSE, FINAL, FINALLY, FLOAT, FOR;
terminal IF, IMPLEMENTS, IMPOR, INSTANCEOF, INT, INTERFACE;
terminal L, LONG;
terminal NATIVE, NEW, NULL;
terminal PACKAG, PRIVATE, PROTECTED, PUBLIC;
terminal RETURN;
terminal SHORT, STATIC, SUPE, SWITCH, SYNCHRONIZED;
terminal THIS, THREADSAFE, THROW, TRANSIENT, TRUE, TRY;
terminal WHILE;
terminal X;

terminal AND, XOR, OR, LTHEN, DLTHEN, LEQU, EQUEQU, BTHEN, BEQU, DBEQU, DBTHEN, TBTHEN, MOD, PLUS, MINUS, MULT;
terminal OPENPAR, CLOSEPAR;
terminal EQU, XOREQU, ANDEQU, PLUSEQU, MINUSEQU, MULTEQU, DIV, DIVEQU, MODEQU, SOREQU, OREQU, NEEQU;
terminal NE, PLUSPLUS, MINUSMINUS, BINNEG;
terminal QUEST, OPENBRAC, CLOSEBRAC, OPENKEYS, CLOSEKEYS, COMMA, SEMIC, DOT, COLON;
terminal STRG;
terminal COMMENTS1, COMMENTS2;
terminal ID, DEC_DIGITS, INT_LITERAL, TEXT;



    //Nao Terminais

non terminal arglist, bit_expression, casting_expression, character, class_declaration, class_name;
non terminal compilation_unit, constructor_declaration, creating_expression, decimal_digits, doc_comment, do_statement;
non terminal exponent_part, expression, field_declaration, float_literal, float_type_suffix, for_statement;
non terminal identifier, if_statement, import_statement, integer_literal, interface_declaration, interface_name;
non terminal literal_expression, logical_expression, method_declaration, modifier, numeric_expression, package_name;
non terminal package_statement, parameter, parameter_list, statement, statement_block, static_initializer;
non terminal string, string_expression, switch_statement, testing_expression, try_statement, type;
non terminal type_declaration, type_specifier, variable_declaration, variable_declarator, variable_initializer, while_statement;

//Auxiliares

non terminal comma_expression_loop;
non terminal modifier_loop, extends_classname_optional, implements_interface_optional, interface_comma_loop, field_declaration_loop;
non terminal package_statement_op, import_statement_loop, type_declaration_loop;
non terminal parameter_list_optional;
non terminal arglist_optional, expression_optional_brac, colchetes_loop;
non terminal doc_comment_optional;
non terminal decimal_digits_optional, exponent_part_optional, float_type_suffix_optional;
non terminal expression_optional;
non terminal else_statement_optional;
non terminal comma_parameter_loop;
non terminal identifier_optional;
non terminal statement_loop;
non terminal character_loop;
non terminal case_expression_default_statement_loop;
non terminal catch_parameter_statement_loop, finally_statement_optional;
non terminal comma_variable_declarator_loop;
non terminal equ_variable_initializer_optional;
non terminal variables_optional, comma_variable_initializer_loop, comma_optional;
non terminal modifier_optional;
non terminal bit_expression_2;
non terminal logical_expression_2, testing_expression_2, numeric_expression_2, numeric_expression_3, string_expression_2, interface_declaration_2, method_declaration_2, type_declaration_2;
non terminal expression_2;

precedence nonassoc DOT,OPENPAR, OPENBRAC;
precedence left PLUS, MINUS;

start with compilation_unit;

 
/* Gramática */

//1

//compilation_unit ::=  package_statement import_statement type_declaration;
					
arglist ::= expression comma_expression_loop ;

comma_expression_loop ::= COMMA expression comma_expression_loop
						| /* vazio*/ ;
						
bit_expression ::= BINNEG expression
				| expression bit_expression_2 expression;
				
bit_expression_2 ::= BEQU
				| DLTHEN
				| DBTHEN
				| TBTHEN;
				
casting_expression ::= OPENPAR type CLOSEPAR expression;

character ::= ID;

class_declaration ::= modifier_loop CLAS identifier extends_classname_optional implements_interface_optional OPENKEYS field_declaration_loop CLOSEKEYS;

modifier_loop ::= modifier modifier_loop
				| /* vazio */ ; 
				
extends_classname_optional ::= EXTEND class_name
							| /* vazio */ ;

implements_interface_optional ::= IMPLEMENTS interface_name interface_comma_loop
								| /* vazio */ ;
								
interface_comma_loop ::= COMMA interface_name interface_comma_loop
						| /* vazio */ ;
							
field_declaration_loop ::= field_declaration field_declaration_loop 
						| /* vazio */ ;
						
class_name ::= identifier
			| package_name DOT identifier;
			
compilation_unit ::= package_statement_op import_statement_loop type_declaration_loop;

package_statement_op ::= package_statement
						| /* vazio */;
						
import_statement_loop ::= import_statement import_statement_loop
						| /* vazio */ ;
						
type_declaration_loop ::= type_declaration type_declaration_loop
						| /* vazio */ ;
						
constructor_declaration ::= modifier_loop identifier OPENPAR parameter_list_optional CLOSEPAR;

parameter_list_optional ::= parameter_list
						| /* vazio */ ;
						
creating_expression ::= NEW class_name OPENPAR arglist_optional CLOSEPAR
					| NEW type_specifier expression_optional_brac colchetes_loop
					| NEW OPENPAR expression CLOSEPAR;
					
arglist_optional ::= arglist
					| /* vazio */ ;
					
expression_optional_brac ::= OPENBRAC expression CLOSEBRAC
					| /* vazio */;
					
colchetes_loop ::= OPENBRAC CLOSEBRAC colchetes_loop
					| /* vazio */ ;
					
decimal_digits ::= DEC_DIGITS;

doc_comment ::= COMMENTS2 TEXT COMMENTS1;

do_statement ::= DO statement WHILE OPENPAR expression CLOSEPAR SEMIC;

exponent_part ::= E decimal_digits
				| E PLUS decimal_digits
				| E MINUS decimal_digits;
				
expression ::= MINUS expression
             | PLUSPLUS expression
             | MINUSMINUS expression
             | expression PLUSPLUS
             | expression MINUSMINUS
             | expression PLUS expression
             | expression PLUSEQU  expression
             | expression MINUS expression
             | expression MINUSEQU expression
             | expression MULT  expression
             | expression MULTEQU expression
             | expression DIV expression
             | expression DIVEQU expression
             | expression MOD expression
             | expression MODEQU expression
                   // Testing Expression
             | expression EQUEQU expression
             | expression NEEQU expression
             | expression EQUEQU expression
             | expression NEEQU expression
             | expression BTHEN expression
             | expression LTHEN expression
             | expression LEQU expression
             | expression BEQU expression
                // Logical Expression
             | NE expression
             | expression AMPERSAND expression
             | expression AMPERSAND EQU expression
             | expression OR expression
             | expression SOREQU expression
             | expression XOR expression
             | expression XOREQU expression
             | expression AMPERSAND AMPERSAND expression
             | expression OREQU expression
             | expression MOD expression
             | expression MODEQU expression
             | expression QUEST expression COLON expression
             | TRUE
             | FALSE
                // String Expression
             | expression PLUS expression
             | expression PLUSEQU expression
                // Bit Expression
             | BINNEG expression
             | expression BEQU expression
             | expression DLTHEN expression
             | expression DBTHEN expression
             | expression TBTHEN expression
                // Casting Expression
             | OPENPAR type CLOSEPAR expression
                // Creating Expression
             | NEW class_name OPENPAR arglist_optional CLOSEPAR
             | NEW type_specifier expression_optional_brac colchetes_loop
             | NEW OPENPAR expression CLOSEPAR
                // Literal Expression
             | integer_literal
             | float_literal
             | string
             | character
                // Terminals
             | NULL
             | SUPE
             | THIS
             | identifier 
             | OPENPAR expression CLOSEPAR
             | expression OPENBRAC arglist_optional CLOSEBRAC
             | expression OPENBRAC expression CLOSEBRAC
             | expression DOT expression
             | expression COMMA expression
             | expression INSTANCEOF class_name
             | expression INSTANCEOF interface_name;
             
expression_2 ::= PLUSPLUS
               | MINUSMINUS
               | PLUS expression
               | PLUSEQU  expression
               | MINUS expression
               | MINUSEQU expression
               | MULT  expression
               | MULTEQU expression
               | DIV expression
               | DIVEQU expression
               | MOD expression
               | MODEQU expression;
             
field_declaration ::= doc_comment_optional method_declaration
					| doc_comment_optional constructor_declaration
					| doc_comment_optional variable_declaration
					| static_initializer
					| SEMIC;
					
					
doc_comment_optional ::= doc_comment
					| /* vazio */;
					
float_literal ::= decimal_digits DOT decimal_digits_optional exponent_part_optional float_type_suffix_optional
				| DOT decimal_digits exponent_part_optional float_type_suffix_optional
				| decimal_digits exponent_part_optional float_type_suffix_optional;
					
decimal_digits_optional ::= decimal_digits
						| /* vazio */;
						
exponent_part_optional ::= exponent_part
						| /* vazio */;
						
float_type_suffix_optional ::= float_type_suffix
							| /* vazio */;
							
float_type_suffix ::= D
					| F;
					
for_statement ::= FOR OPENPAR variable_declaration expression_optional SEMIC expression_optional SEMIC CLOSEPAR statement
				| FOR OPENPAR expression SEMIC expression_optional SEMIC expression_optional SEMIC CLOSEPAR statement
				| FOR OPENPAR SEMIC expression_optional SEMIC expression_optional SEMIC CLOSEPAR statement;

expression_optional ::= expression
					| /* vazio */;
					
identifier ::= ID;

if_statement ::= IF OPENPAR expression CLOSEPAR statement else_statement_optional;

else_statement_optional ::= ELSE statement
							| /* vazio */ ;
							
import_statement ::= IMPOR package_name DOT MULT SEMIC SEMIC
					| IMPOR class_name SEMIC
					| IMPOR interface_name SEMIC;
					
integer_literal ::= INT_LITERAL;

interface_declaration ::= modifier_loop INTERFACE identifier interface_declaration_2 field_declaration_loop CLOSEKEYS;

interface_declaration_2 ::= OPENKEYS | EXTEND interface_name interface_comma_loop OPENKEYS;
						
interface_name ::= identifier
				| package_name DOT identifier;
				
literal_expression ::= integer_literal
		     | float_literal
		     | string
		     | character;
					
logical_expression ::= NE expression
                    | expression logical_expression_2 expression
                    | TRUE
                    | FALSE;
                    
logical_expression_2 ::= AMPERSAND 
                    | AMPERSAND EQU
                    | OR
                    | SOREQU
                    | XOR
                    | XOREQU
                    | AMPERSAND AMPERSAND
                    | OREQU
                    | MOD
                    | MODEQU
                    | QUEST expression COLON;
					
method_declaration ::= modifier_loop type identifier OPENPAR parameter_list_optional CLOSEPAR colchetes_loop method_declaration_2;

method_declaration_2 ::= statement_block |  SEMIC;
modifier ::= PUBLIC
           | PRIVATE
           | PROTECTED
           | STATIC
           | FINAL
           | SYNCHRONIZED
           | ABSTRACT
           | THREADSAFE
           | TRANSIENT;
           
numeric_expression ::= MINUS expression
		     | PLUSPLUS expression
      		     | MINUSMINUS expression                 
                     | expression numeric_expression_3;

numeric_expression_3 ::= PLUSPLUS | 
                         MINUSMINUS | 
                         numeric_expression_2 expression;

numeric_expression_2 ::= PLUS 
		     | PLUSEQU 
		     | MINUS 
		     | MINUSEQU 
		     | MULT 
		     | MULTEQU 
		     | DIV 
		     | DIVEQU 
		     | MOD 
		     | MODEQU
                     ;
				
package_name ::= identifier
				| package_name DOT identifier;
				
package_statement ::= PACKAG package_name SEMIC;

parameter ::= type identifier colchetes_loop;

parameter_list ::= parameter comma_parameter_loop;

comma_parameter_loop ::= COMMA parameter comma_parameter_loop
						| /* vazio */ ;
						
statement ::= variable_declarator
            | expression SEMIC
            | statement_block
            | if_statement
            | do_statement
            | while_statement
            | for_statement
            | try_statement
            | switch_statement
            | SYNCHRONIZED OPENPAR expression CLOSEPAR statement
            | RETURN expression_optional SEMIC 
            | THROW expression SEMIC
            | identifier COLON statement 
            | BREAK identifier_optional SEMIC
            | CONTINUE identifier_optional SEMIC
            | SEMIC;						
						
identifier_optional ::= identifier
					| /* vazio */ ;
					
statement_block ::= OPENKEYS statement_loop CLOSEKEYS;	

statement_loop ::= statement statement_loop
				| /* vazio */ ;
				
static_initializer ::= STATIC statement_block;

string ::= STRG character_loop STRG;

character_loop ::= character character_loop
				| /* vazio */ ;
				
string_expression ::= expression string_expression_2 expression;

string_expression_2 ::= PLUS | 
                        PLUSEQU;
					
switch_statement ::= SWITCH OPENPAR expression CLOSEPAR OPENKEYS case_expression_default_statement_loop CLOSEKEYS;

case_expression_default_statement_loop ::= CASE expression COLON case_expression_default_statement_loop
										| DEFAULT COLON case_expression_default_statement_loop
										| statement;

testing_expression ::= expression testing_expression_2 expression;

testing_expression_2 ::= EQUEQU
                       | NEEQU
                       | BTHEN
                       | LTHEN
                       | LEQU
                       | BEQU
                       ;
					
try_statement ::= TRY statement catch_parameter_statement_loop finally_statement_optional;

catch_parameter_statement_loop ::= CATCH OPENPAR parameter CLOSEPAR statement catch_parameter_statement_loop
								| /* vazio */;
								
finally_statement_optional ::= FINALLY statement
							| /* vazio */ ;
				
type ::= type_specifier colchetes_loop;

type_declaration ::= doc_comment_optional type_declaration_2;

type_declaration_2 ::= class_declaration SEMIC | interface_declaration SEMIC;

type_specifier ::= BOOLEAN
                 | BYTE
                 | CHAR
                 | SHORT
                 | INT
                 | FLOAT
                 | LONG
                 | DOUBLE
                 | class_name
                 | interface_name;
                 
variable_declaration ::= modifier_optional type variable_declarator comma_variable_declarator_loop SEMIC;

modifier_optional ::= modifier
					| /* vazio */;

comma_variable_declarator_loop ::= COMMA variable_declarator comma_variable_declarator_loop
								| /* vazio */;
					
variable_declarator ::= identifier colchetes_loop equ_variable_initializer_optional;	

equ_variable_initializer_optional ::= EQU variable_initializer	
									| /* vazio */ ;		
									
variable_initializer ::= expression
						| OPENKEYS variables_optional CLOSEKEYS;
						
variables_optional ::= variable_initializer comma_variable_initializer_loop	comma_optional
					| /* vazio */ ;

comma_variable_initializer_loop ::= COMMA variable_initializer comma_variable_initializer_loop
								| /* vazio */ ;

comma_optional ::= COMMA
				| /*vazio*/ ;
				
while_statement ::= WHILE OPENPAR expression CLOSEPAR statement;
						
