/* Cï¿½digo do Usuï¿½rio */

package analisadores;
import java_cup.runtime.Symbol;
import java.util.Arrays;
import java.util.LinkedList;
import auxiliares.*;

parser code
{:
    public Util util = new Util();
    public String resultado = "";
    public static LinkedList<TError> TabelaERSintatico = new  LinkedList<TError>();


    public void syntaxError(Symbol symbol){

        String lexema = symbol.value.toString();
        int linha = symbol.right;
        int coluna = symbol.left;
        
        System.out.println("Erro sintatico!");
        System.out.println("\tLexema:   " + lexema);
        System.out.println("\tLinha: " + linha);
        System.out.println("\tColuna: " + coluna);



        TError dados = new TError(lexema, linha, coluna, "Erro Sintatico",  "Caractere nao reconhecido!");
        TabelaERSintatico.add(dados);   
    }

    public void unrecoveredSyntaxError(Symbol symbol) throws java.lang.Exception{
        String lexema = symbol.value.toString();
        int linha = symbol.right;
        int coluna = symbol.left;

        System.out.println("Erro sintatico irrecuperavel!");
        System.out.println("\tLexema:   " + lexema);
        System.out.println("\tLinha: " + linha);
        System.out.println("\tColuna: " + coluna);

        TError dados = new TError(lexema, linha, coluna, "Erro Sintatico",  "Caractere nao reconhecido!");
        TabelaERSintatico.add(dados);
    }
    
:}

    //Aï¿½ï¿½es Gramaticais

action code {:

	ArmazenadorVariavel armazemVar = new ArmazenadorVariavel();
    ArmazenadorMetodos armazemMetodos = new ArmazenadorMetodos();
    ArmazenadorCodigoAssembly armazemCodigo = new ArmazenadorCodigoAssembly();



:}


/* Declaracoes */

    //Terminais
terminal BOOLEAN, CHAR, BYTE, SHORT, INT, LONG, FLOAT, DOUBLE, VOID, STRGN;
terminal PACKAGE, IMPORT;
terminal ABSTRACT, FINAL, PUBLIC, PROTECTED, PRIVATE, STATIC, TRANSIENT, VOLATILE, NATIVE, SYNCHRONIZED;
terminal CLASS, INTERFACE, IMPLEMENTS, OP_DIM, THROWS, EXTENDS, CASE, DEFAULT, IF, SWITCH, ELSE;
terminal WHILE, DO, FOR, BREAK, RETURN, TRY, BOOLLIT, THIS, SUPER, JNULL, OP_INC, OP_DEC;
terminal OP_LE, OP_GE, INSTANCEOF, OP_EQ, OP_NE, OP_LAND, OP_LOR;
terminal ASS_MUL, ASS_DIV, ASS_MOD, ASS_ADD, ASS_SUB, ASS_SHL, ASS_SHR, ASS_SHRR, ASS_AND, ASS_XOR, ASS_OR;
terminal COMMA, SEMIC, DOT, MULT, OPENKEYS, CLOSEKEYS, EQU, OPENPAR, CLOSEPAR, COLON;
terminal OPENBRAC, CLOSEBRAC, TIL, NE, PLUS, MINUS, DIV, MOD, BTHEN, LTHEN, XOR, SOR, AMPER, QUE, CONTINUE, THROW, CATCH, FINALLY, NEW, OP_SHL, OP_SHR, OP_SHRR;

terminal String IDENTIFIER, LITERAL;  
 

non terminal ProgramFile;
non terminal PackageStatement, TypeDeclarations, TypeDeclarationOptSemi;
non terminal TypeDeclaration, ImportStatement, ImportStatements, ClassHeader, Modifiers, Modifier;
non terminal Extends, Interfaces, FieldDeclarations, ClassNameList, FieldDeclarationOptSemi, ClassWord;
non terminal FieldDeclaration, MethodDeclaration, ConstructorDeclaration, StaticInitializer;
non terminal ArrayInitializers;
non terminal Throws; 
non terminal ConstructorDeclarator;
non terminal EmptyStatement, LabelStatement, SelectionStatement;
non terminal IterationStatement, GuardingStatement, ConstantExpression; 
non terminal ForInit, ExpressionStatement, Catches, Finally, CatchHeader;  
non terminal SpecialName;
non terminal ArithmeticUnaryOperator;
non terminal SemiColons, NonStaticInitializer, LocalVariableDeclarationStatement, CompilationUnit;  
non terminal ForExpr, ForIncr, ExpressionStatements, Catch, LogicalUnaryOperator;  
non terminal AssignmentOperator; 

non terminal String Block;
non terminal String PrimitiveType, TypeName, TypeSpecifier, AssignmentExpression, ConditionalOrExpression,  ConditionalExpression, ConditionalAndExpression;
non terminal String EqualityExpression, AndExpression, ExclusiveOrExpression, InclusiveOrExpression;
non terminal String CastExpression, LogicalUnaryExpression, PrimitiveTypeExpression, ClassTypeExpression;
non terminal String MultiplicativeExpression, AdditiveExpression, ShiftExpression, RelationalExpression;
non terminal String UnaryExpression, PostfixExpression, RealPostfixExpression, PrimaryExpression;
non terminal String QualifiedName, NotJustName, NewAllocationExpression, PlainNewAllocationExpression;
non terminal String ArrayAllocationExpression, ClassAllocationExpression, Expression;
non terminal String DimExprs, Dims, DimExpr;
non terminal String ComplexPrimary, ComplexPrimaryNoParenthesis;
non terminal String ArrayAccess, FieldAccess;
non terminal String MethodCall, MethodAccess, VariableInitializer, DeclaratorName, MethodBody, ArgumentList, Parameter;
non terminal String LocalVariableDeclarationsAndStatements, LocalVariableDeclarationOrStatement, Statement, JumpStatement, ParameterList;
non terminal Variavel FieldVariableDeclaration, VariableDeclarators, VariableDeclarator;
non terminal Metodo MethodDeclarator;

precedence nonassoc ELSE, DOT, OPENPAR, OPENBRAC; //eh bom conferir se eh isso mesmo

start with CompilationUnit;

/* Gramatica */

TypeSpecifier::= TypeName:type {: RESULT = type; :} | TypeName:type Dims:val {: RESULT = type + val; :};

TypeName::= PrimitiveType:type {: RESULT = type; :} | QualifiedName:type {: RESULT = type; :} ; // tem que mecher no qualified name depois pra permitir classe como tipo

ClassNameList ::= QualifiedName | ClassNameList COMMA QualifiedName;

PrimitiveType
	::= BOOLEAN:type  {: RESULT = "boolean"; :}
	| CHAR:type       {: RESULT = "char"; :}
	| BYTE:type       {: RESULT = "byte"; :}
	| SHORT:type      {: RESULT = "short"; :}
	| INT:type        {: RESULT = "int"; :}
	| LONG:type       {: RESULT = "long"; :}
	| FLOAT:type      {: RESULT = "float"; :}
	| DOUBLE:type     {: RESULT = "double"; :}
	| VOID:type       {: RESULT = "void"; :}
	| STRGN:type	  {: RESULT = "String"; :}
	;

SemiColons
	::= SEMIC
        | SemiColons SEMIC
        ;

CompilationUnit
	::= ProgramFile
        ;

ProgramFile
	::= PackageStatement ImportStatements TypeDeclarations
	| PackageStatement ImportStatements
	| PackageStatement                  TypeDeclarations
	|                  ImportStatements TypeDeclarations
	| PackageStatement
	|                  ImportStatements
	|                                   TypeDeclarations
	;

PackageStatement
	::= PACKAGE QualifiedName SemiColons
	;

TypeDeclarations
	::= TypeDeclarationOptSemi
	| TypeDeclarations TypeDeclarationOptSemi
	;

TypeDeclarationOptSemi
        ::= TypeDeclaration
        | TypeDeclaration SemiColons
        ;

ImportStatements
	::= ImportStatement
	| ImportStatements ImportStatement
	;

ImportStatement
	::= IMPORT QualifiedName SemiColons
	| IMPORT QualifiedName DOT MULT SemiColons
	;

QualifiedName
	::= IDENTIFIER:lexval {: RESULT = lexval; :}
	| QualifiedName:val DOT IDENTIFIER:lexval {: RESULT = (val + "." + lexval); :}
	;

TypeDeclaration
	::= ClassHeader OPENKEYS FieldDeclarations CLOSEKEYS
	| ClassHeader OPENKEYS CLOSEKEYS
	;

ClassHeader
	::= Modifiers ClassWord IDENTIFIER Extends Interfaces
	| Modifiers ClassWord IDENTIFIER Extends
	| Modifiers ClassWord IDENTIFIER       Interfaces
	|           ClassWord IDENTIFIER Extends Interfaces
	| Modifiers ClassWord IDENTIFIER
	|           ClassWord IDENTIFIER Extends
	|           ClassWord IDENTIFIER       Interfaces
	|           ClassWord IDENTIFIER
	;

Modifiers
	::= Modifier
	| Modifiers Modifier
	;

Modifier
	::= ABSTRACT
	| FINAL
	| PUBLIC
	| PROTECTED
	| PRIVATE
	| STATIC
	| TRANSIENT
	| VOLATILE
	| NATIVE
	| SYNCHRONIZED
	;

ClassWord
	::= CLASS
	| INTERFACE
	;

Interfaces
	::= IMPLEMENTS ClassNameList
	;

FieldDeclarations
	::= FieldDeclarationOptSemi
        | FieldDeclarations FieldDeclarationOptSemi
	;

FieldDeclarationOptSemi
        ::= FieldDeclaration
        | FieldDeclaration SemiColons
        ;

FieldDeclaration
	::= FieldVariableDeclaration SEMIC
	| MethodDeclaration
	| ConstructorDeclaration
	| StaticInitializer
        | NonStaticInitializer
        | TypeDeclaration
	;

FieldVariableDeclaration
	::= Modifiers TypeSpecifier:type VariableDeclarators:var1 {: if(armazemVar.containsVariavel(var1.getNome())){
																		System.out.println("ERRO SEMANTICO, O NOME DE VARIAVEL " + var1.getNome() + " JA ESTA SENDO USADO");
																	} else {
																		if(var1.getTipo() == null || var1.getTipo().equals(type)){
																			Variavel var = new Variavel(var1.getNome(), type);
																			armazemVar.addVariavel(var);
																			RESULT = var;
																		} else {
																			System.out.println("ERRO SEMANTICO, O TIPO DA EXPRESSAO EH DIFERENTE DO TIPO DA VARIAVEL");
																		}
																	}
																 :}
	|           TypeSpecifier:type VariableDeclarators:var1 {: if(armazemVar.containsVariavel(var1.getNome())){
																		System.out.println("ERRO SEMANTICO, O NOME DE VARIAVEL " + var1.getNome() + " JA ESTA SENDO USADO");
																	} else {
																		if(var1.getTipo() == null || var1.getTipo().equals(type)){
																			Variavel var = new Variavel(var1.getNome(), type);
																			armazemVar.addVariavel(var);
																			RESULT = var;
																		} else {
																			System.out.println("ERRO SEMANTICO, O TIPO DA EXPRESSAO EH DIFERENTE DO TIPO DA VARIAVEL");
																		}
																	}
																 :}
	;

VariableDeclarators
	::= VariableDeclarator:var {: RESULT = var; :}
	| VariableDeclarators COMMA VariableDeclarator
	;

VariableDeclarator
	::= DeclaratorName:varname {: RESULT = new Variavel(varname, null);  :}
	| DeclaratorName:varname EQU VariableInitializer:type {: if(armazemVar.containsVariavel(type)) type = armazemVar.getVariavel(type).getTipo();
															RESULT = new Variavel(varname, type); :} //isso eh uma gambiarra pra guardar o nome de uma variavel e o suposto tipo a ser passado pra cima
	;

VariableInitializer
	::= Expression:type {: RESULT = type; :}
	| OPENKEYS CLOSEKEYS
        | OPENKEYS ArrayInitializers CLOSEKEYS
        ;

ArrayInitializers
	::= VariableInitializer
	| ArrayInitializers COMMA VariableInitializer
	| ArrayInitializers COMMA
	;

MethodDeclaration
	::= Modifiers TypeSpecifier:rtype MethodDeclarator:novoMetodo Throws MethodBody:mtype {:  if (mtype == null) mtype = "void";
                                                                                                    if (armazemVar.containsVariavel(mtype)) {
                                                                                                        mtype = armazemVar.getVariavel(mtype).getTipo();
                                                                                                    }
                                                                                                  
if (!rtype.equals(mtype)) {
                                                                                                       System.out.println("ERRO SEMÂNTICO, O RETORNO DO METODO: " + novoMetodo.getNome() + " DEVE SER DO MESMO TIPO DA DECLARAÇÃO" + "."); 
                                                                                                  }
                                                                                              :}
	| Modifiers TypeSpecifier:rtype MethodDeclarator:novoMetodo        MethodBody:mtype {: 
                                                                                    if (mtype == null) mtype = "void";
                                                                                    
                                                                                    if (armazemVar.containsVariavel(mtype)) {
                                                                                        mtype = armazemVar.getVariavel(mtype).getTipo();
                                                                                    }

                                                                                    System.out.println("Return type: " + rtype + " Used return type:" + mtype);
                                                                                    if (!rtype.equals(mtype)) {
                                                                            System.out.println("ERRO SEMÂNTICO, O RETORNO DO METODO: " + novoMetodo.getNome() + " DEVE SER DO MESMO TIPO DA DECLARAÇÃO" + "."); 
                                                                         }
                                                                     :}
	|           TypeSpecifier:rtype MethodDeclarator:novoMetodo Throws MethodBody:mtype {: if (mtype == null) mtype = "void";  
                                                                                    if (armazemVar.containsVariavel(mtype)) {
                                                                                        mtype = armazemVar.getVariavel(mtype).getTipo();
                                                                                    }
                                                                                            if (!rtype.equals(mtype)) {
                                                                            System.out.println("ERRO SEMÂNTICO, O RETORNO DO METODO: " + novoMetodo.getNome() + " DEVE SER DO MESMO TIPO DA DECLARAÇÃO" + "."); 
                                                                         }
                                                                     :}
	|           TypeSpecifier:rtype MethodDeclarator:novoMetodo        MethodBody:mtype {:  if (mtype == null) mtype = "void";
                                                                                                if (armazemVar.containsVariavel(mtype)) {
                                                                                        mtype = armazemVar.getVariavel(mtype).getTipo();
                                                                                    }
                                                                                                 if (!rtype.equals(mtype)) {
                                                                            System.out.println("ERRO SEMÂNTICO, O RETORNO DO METODO: " + novoMetodo.getNome() + " DEVE SER DO MESMO TIPO DA DECLARAÇÃO" + "."); 
                                                                         }
                                                                     :}
	;

MethodDeclarator
	::= DeclaratorName:name OPENPAR ParameterList:types CLOSEPAR {: 
                                                                        String[] paramsAndNames = types.toString().split(",");
                                                                        String[] params = new String[paramsAndNames.length];

                                                                        for (int i = 0; i < paramsAndNames.length; i++) {
                                                                            String[] paramAndName = paramsAndNames[i].split(":");
                                                                            params[i] = paramAndName[0];
                                                                            
                                                                        }
                                                                        
                                                                        if (armazemMetodos.containsMetodo(name, params)){
                                                                            System.out.println("ERRO SEMANTICO, O METODO " + name + "(" + types + ") " + " JA ESTA SENDO USADO");
                                                                        } else {
                                                                            Metodo novoMetodo = new Metodo(name, params);
                                                                            armazemMetodos.addMetodo(novoMetodo);
                                                                            for (int i = 0; i < paramsAndNames.length; i++) {
                                                                                String[] paramAndName = paramsAndNames[i].split(":");
                                                                                armazemVar.addVariavel(paramAndName[1], paramAndName[0]);
                                                                            }
                                                                            
                                                                            RESULT = novoMetodo;    
                                                                        }
                                                                     :}
	| DeclaratorName:name OPENPAR CLOSEPAR {: if (armazemMetodos.containsMetodo(name)){
                                                System.out.println("ERRO SEMANTICO, O METODO " + name + "(" + ") " + " JA ESTA SENDO USADO");
                                             } else {
                                                Metodo novoMetodo = new Metodo(name);
                                                armazemMetodos.addMetodo(novoMetodo);
                                                RESULT = novoMetodo;    
                                             }
                                          :}
	| MethodDeclarator OP_DIM
	;

ParameterList
	::= Parameter:type {: RESULT = type; :}
	| ParameterList:type1 COMMA Parameter:type2 {: RESULT = type1 + "," + type2; :}
	;

Parameter
	::= TypeSpecifier:type DeclaratorName:name {: RESULT = type + ":" + name; :} 
        | FINAL TypeSpecifier:type DeclaratorName:name {: RESULT = type + ":" + name; :}
	;

DeclaratorName
	::= IDENTIFIER:name {: RESULT = name; :}
        | DeclaratorName:name OP_DIM {: RESULT = name; :}
        ;

Throws
	::= THROWS ClassNameList
	;

MethodBody
	::= Block:type {: RESULT = type; :}
	| SEMIC
	;

ConstructorDeclaration
	::= Modifiers ConstructorDeclarator Throws Block
	| Modifiers ConstructorDeclarator        Block
	|           ConstructorDeclarator Throws Block
	|           ConstructorDeclarator        Block
	;

ConstructorDeclarator
	::= IDENTIFIER OPENPAR ParameterList CLOSEPAR
	| IDENTIFIER OPENPAR CLOSEPAR
	;

StaticInitializer
	::= STATIC Block
	;

NonStaticInitializer
        ::= Block
        ;

Extends
	::= EXTENDS TypeName
	| Extends COMMA TypeName
	;

Block
	::= OPENKEYS LocalVariableDeclarationsAndStatements:type CLOSEKEYS {: RESULT = type; :}
	| OPENKEYS CLOSEKEYS {: RESULT = "void"; :}
        ;

LocalVariableDeclarationsAndStatements
	::= LocalVariableDeclarationOrStatement:type {: RESULT = type; :}
	| LocalVariableDeclarationsAndStatements LocalVariableDeclarationOrStatement:type {: RESULT = type; :}
	;

LocalVariableDeclarationOrStatement
	::= LocalVariableDeclarationStatement
	| Statement:type {: RESULT = type; :}
	;

LocalVariableDeclarationStatement
	::= TypeSpecifier:type VariableDeclarators:var1 SEMIC {: 		if(armazemVar.containsVariavel(var1.getNome())){
																		System.out.println("ERRO SEMANTICO, O NOME DE VARIAVEL " + var1.getNome() + " JA ESTA SENDO USADO");
																	} else {
																		if(var1.getTipo() == null || var1.getTipo().equals(type) || !util.verificaExpressaoAritimetica(var1.getTipo(), type).equals("error")){
																			Variavel var = new Variavel(var1.getNome(), type);
																			armazemVar.addVariavel(var);
																			RESULT = var;
																		} else {
																			System.out.println("ERRO SEMANTICO, O TIPO DA EXPRESSAO EH DIFERENTE DO TIPO DA VARIAVEL: " + type + " " + var1.getTipo());
																		}
																	}
																 :}
        | FINAL TypeSpecifier VariableDeclarators SEMIC
	;

Statement
	::= EmptyStatement
	| LabelStatement
	| ExpressionStatement SEMIC
        | SelectionStatement
        | IterationStatement
	| JumpStatement:type {: RESULT = type; :}
	| GuardingStatement
	| Block
	;

EmptyStatement
	::= SEMIC
        ;

LabelStatement
	::= IDENTIFIER COLON
        | CASE ConstantExpression COLON
	| DEFAULT COLON
        ;

ExpressionStatement
	::= Expression
	;

SelectionStatement
	::= IF OPENPAR Expression CLOSEPAR Statement
        | IF OPENPAR Expression CLOSEPAR Statement ELSE Statement
        | SWITCH OPENPAR Expression CLOSEPAR Block
        ;

IterationStatement
	::= WHILE OPENPAR Expression CLOSEPAR Statement
	| DO Statement WHILE OPENPAR Expression CLOSEPAR SEMIC
	| FOR OPENPAR ForInit ForExpr ForIncr CLOSEPAR Statement
	| FOR OPENPAR ForInit ForExpr         CLOSEPAR Statement
	;

ForInit
	::= ExpressionStatements SEMIC
	| LocalVariableDeclarationStatement
	| SEMIC
	;

ForExpr
	::= Expression:type SEMIC {: if (!type.equals("boolean")) System.out.println("ERRO SEMANTICO, A EXPRESSAO DO MEIO DO FOR TEM QUE SER BOOLEAN"); :}
	| SEMIC
	;

ForIncr
	::= ExpressionStatements
	;

ExpressionStatements
	::= ExpressionStatement
	| ExpressionStatements COMMA ExpressionStatement
	;

JumpStatement
	::= BREAK IDENTIFIER SEMIC
	| BREAK            SEMIC
        | CONTINUE IDENTIFIER SEMIC
	| CONTINUE            SEMIC
	| RETURN Expression:type SEMIC {: RESULT = type; :}
	| RETURN            SEMIC {: RESULT = "void"; :}
	| THROW Expression SEMIC
	;

GuardingStatement
	::= SYNCHRONIZED OPENPAR Expression OPENPAR Statement
	| TRY Block Finally
	| TRY Block Catches
	| TRY Block Catches Finally
	;

Catches
	::= Catch
	| Catches Catch
	;

Catch
	::= CatchHeader Block
	;

CatchHeader
	::= CATCH OPENPAR TypeSpecifier IDENTIFIER CLOSEPAR
	| CATCH OPENPAR TypeSpecifier CLOSEPAR
	;

Finally
	::= FINALLY Block
	;

PrimaryExpression
	::= QualifiedName:name {: RESULT = name; :}
	| NotJustName:name {: RESULT = name; :}
	;

NotJustName
	::= SpecialName
	| NewAllocationExpression:type {: RESULT = type ; :}
	| ComplexPrimary:type {: RESULT = type ; :}
	;

ComplexPrimary
	::= OPENPAR Expression:type CLOSEPAR {: RESULT = type ; :}
	| ComplexPrimaryNoParenthesis:type {: RESULT = type ; :}
	;

ComplexPrimaryNoParenthesis
	::= LITERAL:lexval {: if(lexval.contains("'")){
								RESULT = "char";
							}else if(lexval.contains("\"")){
								RESULT = "String";
							}else if(lexval.contains(".")){
								RESULT = "double";
							} else {
								RESULT = "int";
							}  :}
	| BOOLLIT {: RESULT = "boolean"; :}
	| ArrayAccess:type {: RESULT = type ; :}
	| FieldAccess
	| MethodCall:type {: RESULT = type ; :}
	;

ArrayAccess
	::= QualifiedName:type OPENBRAC Expression CLOSEBRAC {: RESULT = type ; :}
	| ComplexPrimary:type OPENBRAC Expression CLOSEBRAC {: RESULT = type ; :}
	;

FieldAccess
	::= NotJustName DOT IDENTIFIER
	| RealPostfixExpression DOT IDENTIFIER
        | QualifiedName DOT THIS
        | QualifiedName DOT CLASS
        | PrimitiveType DOT CLASS
	;

MethodCall
	::=  DOT MethodAccess:name OPENPAR ArgumentList:names CLOSEPAR {: String[] argsName = names.split(",");
                                                                         String[] argsType = new String[argsName.length];

                                                                         for (int i = 0; i < argsName.length; i++) {
                                                                            if (armazemVar.containsVariavel(argsName[i])) {
                                                                                argsType[i] = armazemVar.getVariavel(argsName[i]).getTipo();
                                                                            } else {
                                                                                throw new RuntimeException("O argumento: |" + argsName[i] + "| não existe.");
                                                                            }
                                                                         }
                                                                         
                                                                         if (!armazemMetodos.containsMetodo(name, argsType)) {
                                                                            String strTypes = "";
                                                                            for (int i = 0; i < argsType.length - 1; i++) {
                                                                                strTypes += argsType[i];
                                                                            }
                                                                            strTypes += argsType[argsType.length - 1];
                                                                            throw new RuntimeException("O método |" + name + "(" + strTypes + ")|" + " não existe.");
                                                                         }

                                                                         System.out.println("Acesso a metodo. " + Arrays.toString(argsType)); :}   
                                                                         
	|  DOT MethodAccess:type OPENPAR CLOSEPAR {: RESULT = type; :}
	;

MethodAccess
	::= ComplexPrimaryNoParenthesis:name {: RESULT = name; :}
	| SpecialName
	| QualifiedName:name {: RESULT = name; :}
	;


SpecialName
	::= THIS
	| SUPER
	| JNULL
	;

ArgumentList
	::= Expression:type {: RESULT = type; :}
	| ArgumentList:type1 COMMA Expression:type2 {: RESULT = type1 + "," + type2; :}
	;

NewAllocationExpression
        ::= PlainNewAllocationExpression:type {: RESULT = type; :}
        | QualifiedName DOT PlainNewAllocationExpression:type {: RESULT = type; :}
        ;

PlainNewAllocationExpression
    	::= ArrayAllocationExpression:type {: RESULT = type; :}
    	| ClassAllocationExpression:type {: RESULT = type; :}
    	| ArrayAllocationExpression:type OPENKEYS CLOSEKEYS {: RESULT = type; :}
    	| ClassAllocationExpression:type OPENKEYS CLOSEKEYS {: RESULT = type; :}
    	| ArrayAllocationExpression:type OPENKEYS ArrayInitializers CLOSEKEYS {: RESULT = type; :}
    	| ClassAllocationExpression:type OPENKEYS FieldDeclarations CLOSEKEYS {: RESULT = type; :}
    	;

ClassAllocationExpression
	::= NEW TypeName:type OPENPAR ArgumentList CLOSEPAR {: RESULT = type; :}
	| NEW TypeName:type OPENPAR CLOSEPAR {: RESULT = type; :}
        ;

ArrayAllocationExpression
	::= NEW TypeName:t1 DimExprs:t2 Dims:t3 {: RESULT = t1 + t2 + t3; :}
	| NEW TypeName:t1 DimExprs:t2 {: RESULT = t1 + t2; :}
        | NEW TypeName:t1 Dims:t2 {: RESULT = t1 + t2; :}
	;

DimExprs
	::= DimExpr:val {: RESULT = val ; :}
	| DimExprs:val1 DimExpr:val2 {: RESULT = val1 + val2 ; :}
	;

DimExpr
	::= OPENBRAC Expression:type CLOSEBRAC {: RESULT = "[" + type + "]" ; :}
	;

Dims
	::= OP_DIM {: RESULT = "[]"; :}
	| Dims:val OP_DIM {: RESULT = val + "[]"; :}
	;

PostfixExpression
	::= PrimaryExpression:type {: RESULT = type; :}
	| RealPostfixExpression:type {: RESULT = type; :}
	;

RealPostfixExpression
	::= PostfixExpression:type OP_INC {: RESULT = type; :}
	| PostfixExpression:type OP_DEC {: RESULT = type; :}
	;

UnaryExpression
	::= OP_INC UnaryExpression
	| OP_DEC UnaryExpression
	| ArithmeticUnaryOperator CastExpression:type {: RESULT = type; :}
	| LogicalUnaryExpression:type {: RESULT = type; :}
	;

LogicalUnaryExpression
	::= PostfixExpression:type {: RESULT = type; :}
	| LogicalUnaryOperator UnaryExpression:type {: RESULT = type; :}
	;

LogicalUnaryOperator
	::= TIL
	| NE
	;

ArithmeticUnaryOperator
	::= PLUS
	| MINUS
	;

CastExpression
	::= UnaryExpression:type {: RESULT = type; :}
	| OPENPAR PrimitiveTypeExpression CLOSEPAR CastExpression
	| OPENPAR ClassTypeExpression CLOSEPAR CastExpression
	| OPENPAR Expression CLOSEPAR LogicalUnaryExpression
	;

PrimitiveTypeExpression
	::= PrimitiveType
        | PrimitiveType Dims
        ;

ClassTypeExpression
	::= QualifiedName Dims
        ;

MultiplicativeExpression
	::= CastExpression:type {: RESULT = type; :}
	| MultiplicativeExpression:type1 MULT CastExpression:type2 {: if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
																		if (util.verificaExpressaoAritimetica(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaExpressaoAritimetica(type1,type2);
                                                                        }
                                                                     :} 
	| MultiplicativeExpression:type1 DIV CastExpression:type2 {: if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
																		if (util.verificaExpressaoAritimetica(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaExpressaoAritimetica(type1,type2);
                                                                        }
                                                                     :} 
	| MultiplicativeExpression:type1 MOD CastExpression:type2 {: if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
																		if (util.verificaExpressaoAritimetica(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaExpressaoAritimetica(type1,type2);
                                                                        }
                                                                     :} 
	;

AdditiveExpression
	::= MultiplicativeExpression:type {: RESULT = type; :}
        | AdditiveExpression:type1 PLUS MultiplicativeExpression:type2 {: if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo(); 
        																if (util.verificaExpressaoAritimetica(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaExpressaoAritimetica(type1,type2);
                                                                        }
                                                                     :} 
                                                                        
	| AdditiveExpression:type1 MINUS MultiplicativeExpression:type2 {: if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
																		if (util.verificaExpressaoAritimetica(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaExpressaoAritimetica(type1,type2);
                                                                        }
                                                                     :} 
        ;

ShiftExpression
	::= AdditiveExpression:type {: RESULT = type; :}
        | ShiftExpression OP_SHL AdditiveExpression
        | ShiftExpression OP_SHR AdditiveExpression
        | ShiftExpression OP_SHRR AdditiveExpression
	;

RelationalExpression
	::= ShiftExpression:type {: RESULT = type; :}
        | RelationalExpression:type1 LTHEN ShiftExpression:type2 {:  	if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
                                                                        if (util.verificaTiposNumericos(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaTiposNumericos(type1,type2);
                                                                        }
                                                                     :}
	| RelationalExpression:type1 BTHEN ShiftExpression:type2 {:  		if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
                                                                        if (util.verificaTiposNumericos(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaTiposNumericos(type1,type2);
                                                                        }
                                                                     :}
	| RelationalExpression:type1 OP_LE ShiftExpression:type2 {: 		if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
                                                                        if (util.verificaTiposNumericos(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaTiposNumericos(type1,type2);
                                                                        }
                                                                     :}
	| RelationalExpression:type1 OP_GE ShiftExpression:type2 {:  		if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
                                                                        if (util.verificaTiposNumericos(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaTiposNumericos(type1,type2);
                                                                        }
                                                                     :}
	| RelationalExpression INSTANCEOF TypeSpecifier
	;

EqualityExpression
	::= RelationalExpression:type {: RESULT = type; :}

        | EqualityExpression:type1 OP_EQ RelationalExpression:type2 {:  if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
        																if (type1.equals(type2)){ RESULT = type1;}
                                                                        if (util.verificaTiposNumericos(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaTiposNumericos(type1,type2);
                                                                        }
                                                                     :}

        | EqualityExpression:type1 OP_NE RelationalExpression:type2 {:  if(armazemVar.containsVariavel(type1)) type1 = armazemVar.getVariavel(type1).getTipo();
        																if(armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
        																if (type1.equals(type2)){ RESULT = type1;}
                                                                        if (util.verificaTiposNumericos(type1,type2).equals("error")){
                                                                           System.out.println("ERRO SEMANTICO"); 
                                                                        }else{
                                                                            RESULT = util.verificaTiposNumericos(type1,type2);
                                                                        }
                                                                     :}
        ;

AndExpression
	::= EqualityExpression:type {: RESULT = type; :}
        | AndExpression:type1 AMPER EqualityExpression:type2 {: if(type1.equals(type2)){
										    RESULT = type1;} else { 
										    System.out.println("ERRO SEMANTICO");
										     } :}
        ;

ExclusiveOrExpression
	::= AndExpression:type {: RESULT = type; :}
	| ExclusiveOrExpression:type1 XOR AndExpression:type2 {: if(type1.equals(type2)){
										    RESULT = type1;} else { 
										    System.out.println("ERRO SEMANTICO");
										     } :}
	;

InclusiveOrExpression
	::= ExclusiveOrExpression:type  {: RESULT = type; :}
	| InclusiveOrExpression:type1 SOR ExclusiveOrExpression:type2 {: if(type1.equals(type2)){
										    RESULT = type1;} else { 
										    System.out.println("ERRO SEMANTICO");
										     } :}
	;

ConditionalAndExpression
	::= InclusiveOrExpression:type {: RESULT = type; :}
	| ConditionalAndExpression:type1 OP_LAND InclusiveOrExpression:type2 {: if(type1.equals(type2)){
													RESULT = type1;} else { 
													System.out.println("ERRO SEMANTICO");
													} :}
	;
	

ConditionalOrExpression
	::= ConditionalAndExpression:type {: RESULT = type; :}
	| ConditionalOrExpression:type1 OP_LOR ConditionalAndExpression:type2 {: if(type1.equals(type2)){
													RESULT = type1;} else { 
													System.out.println("ERRO SEMANTICO");
                                                                                                        } :}
	;

ConditionalExpression
	::= ConditionalOrExpression:type {: RESULT = type; :}
	| ConditionalOrExpression QUE Expression COLON ConditionalExpression
	;

AssignmentExpression
	::= ConditionalExpression:type  {: RESULT = type; :}
	| UnaryExpression:varname AssignmentOperator AssignmentExpression:type2 {: if(armazemVar.containsVariavel(varname)){
                                                                                        if (armazemVar.containsVariavel(type2)) type2 = armazemVar.getVariavel(type2).getTipo();
																					String type1 = armazemVar.getVariavel(varname).getTipo();
																					if(type1.equals(type2)){
																						RESULT = type1;
																					} else {
																						System.out.println("ERRO SEMANTICO NA ATRIBUICAO. OS DOIS VALORES TEM QUE SER DO MESMO TIPO: " + type1 + " " + type2);
																					}
																				} else {
																					System.out.println("ERRO SEMANTICO, VARIAVEL " + varname + " NAO EXISTE. CRIE ELA ANTES DE USAR");
																				}
																																								
																				:}
	;

AssignmentOperator
	::= EQU
	| ASS_MUL
	| ASS_DIV
	| ASS_MOD
	| ASS_ADD
	| ASS_SUB
	| ASS_SHL
	| ASS_SHR
	| ASS_SHRR
	| ASS_AND
	| ASS_XOR
	| ASS_OR
	;

Expression
	::= AssignmentExpression:type {: RESULT = type; :}
        ;

ConstantExpression
	::= ConditionalExpression
	;	